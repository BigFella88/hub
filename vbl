-- Place this in a LocalScript under StarterPlayerScripts

-- == SERVICES ==
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- == CREATE KEY SYSTEM UI ==
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "KeySystemUI"
ScreenGui.IgnoreGuiInset = true
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = player:WaitForChild("PlayerGui")

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 300, 0, 200)
Frame.Position = UDim2.new(0.5, -150, 0.5, -100)
Frame.BackgroundColor3 = Color3.fromRGB(50, 0, 100) -- Dark purple
Frame.BorderSizePixel = 0
Frame.Active = true -- Makes it draggable
Frame.Draggable = true -- Enables dragging
Frame.Parent = ScreenGui

-- Add corner rounding
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = Frame

-- Title
local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 40)
Title.Position = UDim2.new(0, 0, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Key System"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 20
Title.TextStrokeTransparency = 0.8
Title.Parent = Frame

-- Key Input
local KeyInput = Instance.new("TextBox")
KeyInput.Size = UDim2.new(0.9, 0, 0, 40)
KeyInput.Position = UDim2.new(0.05, 0, 0.3, 0)
KeyInput.BackgroundColor3 = Color3.fromRGB(70, 0, 140) -- Lighter purple
KeyInput.TextColor3 = Color3.fromRGB(255, 255, 255)
KeyInput.PlaceholderText = "Enter Key Here"
KeyInput.PlaceholderColor3 = Color3.fromRGB(200, 200, 200)
KeyInput.Font = Enum.Font.Gotham
KeyInput.TextSize = 16
KeyInput.ClearTextOnFocus = false
KeyInput.Parent = Frame

local KeyInputCorner = Instance.new("UICorner")
KeyInputCorner.CornerRadius = UDim.new(0, 8)
KeyInputCorner.Parent = KeyInput

-- Submit Button
local SubmitButton = Instance.new("TextButton")
SubmitButton.Size = UDim2.new(0.4, 0, 0, 40)
SubmitButton.Position = UDim2.new(0.05, 0, 0.65, 0)
SubmitButton.BackgroundColor3 = Color3.fromRGB(90, 0, 180) -- Medium purple
SubmitButton.Text = "Submit"
SubmitButton.TextColor3 = Color3.fromRGB(255, 255, 255)
SubmitButton.Font = Enum.Font.GothamBold
SubmitButton.TextSize = 16
SubmitButton.Parent = Frame

local SubmitButtonCorner = Instance.new("UICorner")
SubmitButtonCorner.CornerRadius = UDim.new(0, 8)
SubmitButtonCorner.Parent = SubmitButton

-- Get Key Button
local GetKeyButton = Instance.new("TextButton")
GetKeyButton.Size = UDim2.new(0.4, 0, 0, 40)
GetKeyButton.Position = UDim2.new(0.55, 0, 0.65, 0)
GetKeyButton.BackgroundColor3 = Color3.fromRGB(90, 0, 180) -- Medium purple
GetKeyButton.Text = "Get Key"
GetKeyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
GetKeyButton.Font = Enum.Font.GothamBold
GetKeyButton.TextSize = 16
GetKeyButton.Parent = Frame

local GetKeyButtonCorner = Instance.new("UICorner")
GetKeyButtonCorner.CornerRadius = UDim.new(0, 8)
GetKeyButtonCorner.Parent = GetKeyButton

-- Notification Function
local function notify(message, duration)
    StarterGui:SetCore("SendNotification", {
        Title = "Key System",
        Text = message,
        Duration = duration or 3
    })
end

-- Key Validation
local correctKey = "FREE_7282828290AGB6393"
local keyLink = "https://direct-link.net/174459/lyez-hub-key-system"

local function checkKey()
    local input = KeyInput.Text
    if input == correctKey then
        notify("Key accepted! Loading script...", 2)
        ScreenGui:Destroy() -- Remove key UI
        loadMainScript() -- Proceed to load the main script
    else
        notify("Invalid key! Please try again.", 3)
        KeyInput.Text = ""
    end
end

-- Button Connections
SubmitButton.MouseButton1Click:Connect(checkKey)

GetKeyButton.MouseButton1Click:Connect(function()
    setclipboard(keyLink)
    notify("Key link copied to clipboard!", 3)
end)

-- Support Enter key on mobile/PC
KeyInput.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        checkKey()
    end
end)

-- Mobile Dragging Support
local dragging = false
local dragStart = nil
local startPos = nil

Frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = Frame.Position
    end
end)

Frame.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
        local delta = input.Position - dragStart
        Frame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

-- == MAIN SCRIPT ==
function loadMainScript()
    -- == LOAD THE OBSIDIAN UI LIBRARY ==
    local success, Library = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/Library.lua"))()
    end)

    if not success or not Library then
        warn("Failed to load Obsidian UI Library! Error: " .. tostring(Library))
        return
    end
    print("Obsidian UI Library loaded successfully")

    -- == CREATE THE UI WINDOW ==
    local Window
    success, Window = pcall(function()
        return Library:CreateWindow({
            Title = "Lyez",
            Footer = "v1.0.0",
            ToggleKeybind = Enum.KeyCode.RightControl,
            Center = true,
            AutoShow = true
        })
    end)

    if not success or not Window then
        warn("Failed to create UI window! Error: " .. tostring(Window))
        return
    end
    print("UI window created successfully")

    -- == CREATE TABS IN THE WINDOW ==
    local MainTab = Window:AddTab("Main", "home")
    local StatModifierTab = Window:AddTab("Stat Modifier", "stats")
    local OtherTab = Window:AddTab("Other", "misc")
    local UiSettingsTab = Window:AddTab("Ui Settings", "settings")

    -- == CREATE GROUPBOXES FOR MAIN TAB ==
    local MainGroupbox = MainTab:AddLeftGroupbox("Main")
    local MovementGroupbox = MainTab:AddRightGroupbox("Movement Settings")
    local ServeGroupbox = MainTab:AddRightGroupbox("Serve Settings")

    -- == CREATE GROUPBOXES FOR STAT MODIFIER TAB ==
    local StatsGroupbox = StatModifierTab:AddLeftGroupbox("Stats")
    local StatMovementGroupbox = StatModifierTab:AddRightGroupbox("Movement")

    -- == CREATE GROUPBOXES FOR OTHER TAB ==
    local NameChangerGroupbox = OtherTab:AddLeftGroupbox("Name Changer")

    -- == CREATE GROUPBOXES FOR UI SETTINGS TAB ==
    local UiCustomizationGroupbox = UiSettingsTab:AddLeftGroupbox("UI Customization")

    -- == SERVICES ==
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Debris = game:GetService("Debris")

    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    -- == CONFIGURATION VARIABLES ==
    local hitboxEnabled = false
    local EXTENDED_RANGE = 10
    local sphereTransparency = 0.7
    local sphereColor = Color3.fromRGB(255, 0, 0)
    local outlineColor = Color3.fromRGB(139, 0, 0)
    local HIT_COOLDOWN = 1
    local lastHitTime = 0

    local aimEnabled = false
    local beamColor = Color3.fromRGB(255, 0, 0)
    local beamWidth = 2
    local aimDistance = 20

    local midAirEnabled = false
    local midAirSpeed = 20

    local serveOverrideEnabled = false

    local statModifierEnabled = false
    local multipliers = {
        Speed = 1.5,
        SpikePower = 1.5,
        JumpPower = 1.5,
        BumpPower = 1.5,
        DiveSpeed = 1.5,
        ServePower = 1.5,
        SetPower = 1.5,
        BlockPower = 1.5
    }
    local baseStats = {
        WalkSpeed = 16,
        JumpHeight = 7.2
    }

    -- == STORAGE FOR HITBOX SPHERES, BEAMS, AND CONNECTIONS ==
    local sphereReferences = {}
    local beams = {}
    local midAirConnections = {}
    local statConnections = {}

    -- == FIND THE INTERACT REMOTE FUNCTION ==
    local interactRemote = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_knit@1.7.0"):WaitForChild("knit"):WaitForChild("Services"):WaitForChild("BallService"):WaitForChild("RF"):WaitForChild("Interact")
    if not interactRemote then
        print("Interact RemoteFunction not found!")
        return
    end
    print("Interact RemoteFunction found")

    -- == HITBOX EXTENDER FUNCTIONS ==
    local function getBallId(ballModel)
        local ballId = tonumber(ballModel.Name:match("CLIENT_BALL_(%d+)"))
        return ballId
    end

    local function findClosestBall()
        local closestBall, closestBallModel, closestDistance = nil, nil, EXTENDED_RANGE + 5
        for _, descendant in pairs(Workspace:GetDescendants()) do
            if descendant.Name:match("BALL") then
                local ballPart = descendant:FindFirstChildWhichIsA("BasePart", true)
                if ballPart then
                    local distance = (humanoidRootPart.Position - ballPart.Position).Magnitude
                    if distance <= EXTENDED_RANGE and distance < closestDistance then
                        closestDistance = distance
                        closestBall = ballPart
                        closestBallModel = descendant
                    end
                end
            end
        end
        return closestBall, closestBallModel
    end

    local function createHitboxSphere(ball, ballModel)
        if not ball:IsA("BasePart") then
            print("Ball is not a BasePart in model:", ballModel.Name)
            return
        end

        print("Creating hitbox sphere for ball:", ball.Name, "in model:", ballModel.Name)

        local sphere = Instance.new("Part")
        sphere.Name = "HitboxSphere"
        sphere.Size = Vector3.new(EXTENDED_RANGE * 2, EXTENDED_RANGE * 2, EXTENDED_RANGE * 2)
        sphere.Shape = Enum.PartType.Ball
        sphere.Position = ball.Position
        sphere.Anchored = false
        sphere.CanCollide = false
        sphere.Transparency = sphereTransparency
        sphere.Color = sphereColor

        local outlineSphere = Instance.new("Part")
        outlineSphere.Name = "OutlineSphere"
        outlineSphere.Size = Vector3.new(EXTENDED_RANGE * 2 + 0.2, EXTENDED_RANGE * 2 + 0.2, EXTENDED_RANGE * 2 + 0.2)
        outlineSphere.Shape = Enum.PartType.Ball
        outlineSphere.Position = ball.Position
        outlineSphere.Anchored = false
        outlineSphere.CanCollide = false
        outlineSphere.Transparency = sphereTransparency - 0.2
        outlineSphere.Color = outlineColor

        local weldMain = Instance.new("WeldConstraint")
        weldMain.Part0 = ball
        weldMain.Part1 = sphere
        weldMain.Parent = sphere

        local weldOutline = Instance.new("WeldConstraint")
        weldOutline.Part0 = sphere
        weldOutline.Part1 = outlineSphere
        weldOutline.Parent = outlineSphere

        sphere.Parent = ballModel
        outlineSphere.Parent = ballModel

        sphereReferences[ballModel] = { main = sphere, outline = outlineSphere }

        print("Hitbox sphere created and welded for ball:", ball.Name, "Position:", sphere.Position)
    end

    local function updateSpheres()
        for ballModel, spheres in pairs(sphereReferences) do
            if spheres.main and spheres.outline then
                spheres.main.Size = Vector3.new(EXTENDED_RANGE * 2, EXTENDED_RANGE * 2, EXTENDED_RANGE * 2)
                spheres.outline.Size = Vector3.new(EXTENDED_RANGE * 2 + 0.2, EXTENDED_RANGE * 2 + 0.2, EXTENDED_RANGE * 2 + 0.2)
                spheres.main.Transparency = sphereTransparency
                spheres.outline.Transparency = sphereTransparency - 0.2
                spheres.main.Color = sphereColor
                spheres.outline.Color = outlineColor
            end
        end
    end

    local function removeSpheres()
        for ballModel, spheres in pairs(sphereReferences) do
            if spheres.main then spheres.main:Destroy() end
            if spheres.outline then spheres.outline:Destroy() end
            sphereReferences[ballModel] = nil
        end
    end

    Workspace.DescendantRemoving:Connect(function(descendant)
        if descendant.Name:match("BALL") then
            if sphereReferences[descendant] then
                local spheres = sphereReferences[descendant]
                if spheres.main then spheres.main:Destroy() end
                if spheres.outline then spheres.outline:Destroy() end
                sphereReferences[descendant] = nil
                print("Removed hitbox sphere for ball model:", descendant.Name)
            end
        end
    end)

    Workspace.DescendantAdded:Connect(function(descendant)
        if not hitboxEnabled then return end
        if not descendant.Name:match("BALL") then return end

        print("Detected potential ball model:", descendant.Name)

        local ballPart
        local startTime = tick()
        local timeout = 5
        while not ballPart and (tick() - startTime) < timeout do
            ballPart = descendant:FindFirstChildWhichIsA("BasePart", true)
            if not ballPart then
                task.wait(0.1)
            end
        end

        if ballPart then
            print("Found BasePart in ball model:", ballPart.Name)
            createHitboxSphere(ballPart, descendant)
        else
            print("No BasePart found in ball model after timeout:", descendant.Name)
            local children = descendant:GetChildren()
            local childNames = {}
            for _, child in pairs(children) do
                table.insert(childNames, child.Name .. " (" .. child.ClassName .. ")")
            end
            print("DEBUG: Children of ball model: " .. table.concat(childNames, ", "))
        end
    end)

    for _, descendant in pairs(Workspace:GetDescendants()) do
        if hitboxEnabled and descendant.Name:match("BALL") then
            print("Detected existing ball model:", descendant.Name)
            local ballPart = descendant:FindFirstChildWhichIsA("BasePart", true)
            if ballPart then
                createHitboxSphere(ballPart, descendant)
            else
                print("No BasePart found in ball model:", descendant.Name)
                for _, child in pairs(descendant:GetChildren()) do
                    print("Child in ball model:", child.Name, "Type:", child.ClassName)
                end
            end
        end
    end

    -- == AIMING BEAM FUNCTIONS ==
    local function createAimIndicator(character)
        if not character then
            print("Cannot create beam: character is nil")
            return
        end
        
        local startTime = tick()
        local timeout = 10
        while not character:FindFirstChild("HumanoidRootPart") do
            if tick() - startTime > timeout then
                print("Timeout waiting for HumanoidRootPart for character:", character.Name)
                return
            end
            task.wait(0.1)
        end
        
        local attachment0 = Instance.new("Attachment")
        attachment0.Position = Vector3.new(0, 0, 0)
        attachment0.Parent = character.HumanoidRootPart
        
        local attachment1 = Instance.new("Attachment")
        attachment1.Parent = character.HumanoidRootPart
        
        local beam = Instance.new("Beam")
        beam.Attachment0 = attachment0
        beam.Attachment1 = attachment1
        beam.Width0 = beamWidth
        beam.Width1 = beamWidth
        beam.Brightness = 1
        beam.LightEmission = 1
        beam.Color = ColorSequence.new(beamColor)
        beam.Parent = character.HumanoidRootPart
        
        beams[character] = beam
        print("Beam created for character:", character.Name)
        
        local connection
        connection = RunService.Heartbeat:Connect(function()
            if not character or not character.Parent or not character:FindFirstChild("HumanoidRootPart") then
                connection:Disconnect()
                if beams[character] then
                    beams[character]:Destroy()
                    beams[character] = nil
                    print("Beam removed for character (update loop):", character and character.Name or "nil")
                end
                return
            end
            
            local rootPart = character.HumanoidRootPart
            local forwardVector = rootPart.CFrame.LookVector
            local localOffset = rootPart.CFrame:VectorToObjectSpace(forwardVector * aimDistance)
            attachment1.Position = localOffset
        end)
    end

    local function removeBeam(character)
        if beams[character] then
            beams[character]:Destroy()
            beams[character] = nil
            print("Beam removed for character:", character and character.Name or "nil")
        end
    end

    -- == MID-AIR CONTROL FUNCTIONS ==
    local function setupMidAirControl(player)
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        local rootPart = character:WaitForChild("HumanoidRootPart")

        local connections = {}
        midAirConnections[player] = connections

        local stateConnection = humanoid.StateChanged:Connect(function(oldState, newState)
            if newState == Enum.HumanoidStateType.Freefall or newState == Enum.HumanoidStateType.Jumping then
                humanoid.AutoRotate = true
            end
        end)
        table.insert(connections, stateConnection)

        local inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not midAirEnabled then return end
            if gameProcessed then return end

            if humanoid:GetState() == Enum.HumanoidStateType.Freefall or humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                local moveDirection = Vector3.new()

                if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.Up then
                    moveDirection = moveDirection + Vector3.new(0, 0, -1)
                elseif input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.Down then
                    moveDirection = moveDirection + Vector3.new(0, 0, 1)
                elseif input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.Left then
                    moveDirection = moveDirection + Vector3.new(-1, 0, 0)
                elseif input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.Right then
                    moveDirection = moveDirection + Vector3.new(1, 0, 0)
                end

                if moveDirection.Magnitude > 0 then
                    moveDirection = moveDirection.Unit
                    local velocityBoost = moveDirection * midAirSpeed
                    rootPart.Velocity = Vector3.new(
                        velocityBoost.X,
                        rootPart.Velocity.Y,
                        velocityBoost.Z
                    )
                end
            end
        end)
        table.insert(connections, inputConnection)
    end

    local function disableMidAirControl(player)
        if midAirConnections[player] then
            for _, connection in pairs(midAirConnections[player]) do
                connection:Disconnect()
            end
            midAirConnections[player] = nil
        end
    end

    -- == SERVE POWER OVERRIDE FUNCTIONS ==
    local serveFunction = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index")
        :WaitForChild("sleitnick_knit@1.7.0"):WaitForChild("knit")
        :WaitForChild("Services"):WaitForChild("GameService"):WaitForChild("RF"):WaitForChild("Serve")

    local oldNamecall
    local function setupServeOverride()
        if oldNamecall then return end

        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            local args = {...}

            if self == serveFunction and method == "InvokeServer" and serveOverrideEnabled then
                print("Serve invoked with power: " .. tostring(args[2]) .. ". Overriding to max power!")
                args[2] = 1
                return oldNamecall(self, unpack(args))
            end

            return oldNamecall(self, ...)
        end)
        print("Serve power override hook set up.")
    end

    local function disableServeOverride()
        serveOverrideEnabled = false
        print("Serve power override disabled.")
    end

    -- == STAT MODIFIER FUNCTIONS ==
    local function applyStatModifiers()
        local character = player.Character
        if not character then return end

        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not rootPart then return end

        if statModifierEnabled then
            humanoid.WalkSpeed = baseStats.WalkSpeed * multipliers.Speed
            humanoid.JumpHeight = baseStats.JumpHeight * multipliers.JumpPower
            print("DEBUG: Applied Humanoid boosts - WalkSpeed = " .. humanoid.WalkSpeed .. ", JumpHeight = " .. humanoid.JumpHeight)
            if humanoid.JumpHeight == 0 then
                humanoid.JumpPower = (baseStats.JumpHeight * 7) * multipliers.JumpPower
                print("DEBUG: Fallback to JumpPower - JumpPower = " .. humanoid.JumpPower)
            end

            local aura = Instance.new("ParticleEmitter")
            aura.Color = ColorSequence.new(Color3.new(0.9, 0, 0.9), Color3.new(1, 0, 1))
            aura.Size = NumberSequence.new(0.5, 0)
            aura.Lifetime = NumberRange.new(1)
            aura.Rate = 20
            aura.Parent = rootPart
            Debris:AddItem(aura, 5)
        else
            humanoid.WalkSpeed = baseStats.WalkSpeed
            humanoid.JumpHeight = baseStats.JumpHeight
            humanoid.JumpPower = baseStats.JumpHeight * 7
            print("DEBUG: Reset Humanoid stats - WalkSpeed = " .. humanoid.WalkSpeed .. ", JumpHeight = " .. humanoid.JumpHeight)
        end

        local statsModule = nil
        local possibleLocations = {
            player:FindFirstChild("PlayerStats"),
            ReplicatedStorage:FindFirstChild("PlayerStats"),
            ReplicatedStorage:FindFirstChild("GameData"),
            ReplicatedStorage:FindFirstChild("PlayerData"),
            player:FindFirstChild("Stats"),
            character:FindFirstChild("Stats"),
            player:FindFirstChild("leaderstats"),
            character:FindFirstChild("PlayerStats"),
            ReplicatedStorage:FindFirstChild("Data"),
            ReplicatedStorage:FindFirstChild("Stats")
        }

        for _, location in pairs(possibleLocations) do
            if location then
                statsModule = location
                print("DEBUG: Stats module found at " .. tostring(statsModule:GetFullName()))
                break
            end
        end

        if statsModule and statModifierEnabled then
            for stat, multiplier in pairs(multipliers) do
                local statValue = statsModule:FindFirstChild(stat)
                if statValue then
                    local oldValue = statValue.Value
                    statValue.Value = statValue.Value * multiplier
                    print("DEBUG: Applied " .. stat .. " multiplier: " .. oldValue .. " -> " .. statValue.Value)
                else
                    warn("DEBUG: Stat " .. stat .. " not found in stats module")
                end
            end
        else
            warn("DEBUG: No stats module found in common locations. Humanoid boosts applied.")
            local function getNames(instances)
                local names = {}
                for _, instance in pairs(instances) do
                    table.insert(names, instance.Name)
                end
                return table.concat(names, ", ")
            end
            print("DEBUG: Player children: " .. getNames(player:GetChildren()))
            print("DEBUG: Character children: " .. getNames(character:GetChildren()))
            print("DEBUG: ReplicatedStorage children: " .. getNames(ReplicatedStorage:GetChildren()))
        end
    end

    local function setupStatModifiers(player)
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        local rootPart = character:WaitForChild("HumanoidRootPart")

        local connections = {}
        statConnections[player] = connections

        local walkSpeedConnection = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if not statModifierEnabled then return end
            if humanoid.WalkSpeed ~= baseStats.WalkSpeed * multipliers.Speed then
                humanoid.WalkSpeed = baseStats.WalkSpeed * multipliers.Speed
                print("DEBUG: WalkSpeed reset to " .. humanoid.WalkSpeed)
            end
        end)
        table.insert(connections, walkSpeedConnection)

        local jumpHeightConnection = humanoid:GetPropertyChangedSignal("JumpHeight"):Connect(function()
            if not statModifierEnabled then return end
            if humanoid.JumpHeight ~= baseStats.JumpHeight * multipliers.JumpPower then
                humanoid.JumpHeight = baseStats.JumpHeight * multipliers.JumpPower
                print("DEBUG: JumpHeight reset to " .. humanoid.JumpHeight)
            end
        end)
        table.insert(connections, jumpHeightConnection)

        local jumpPowerConnection = humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
            if not statModifierEnabled then return end
            if humanoid.JumpHeight == 0 then
                local targetJumpPower = (baseStats.JumpHeight * 7) * multipliers.JumpPower
                if humanoid.JumpPower ~= targetJumpPower then
                    humanoid.JumpPower = targetJumpPower
                    print("DEBUG: JumpPower reset to " .. humanoid.JumpPower)
                end
            end
        end)
        table.insert(connections, jumpPowerConnection)

        player.CharacterAdded:Connect(function(newCharacter)
            humanoid = newCharacter:WaitForChild("Humanoid")
            rootPart = newCharacter:WaitForChild("HumanoidRootPart")
            applyStatModifiers()
        end)
    end

    local function disableStatModifiers(player)
        if statConnections[player] then
            for _, connection in pairs(statConnections[player]) do
                connection:Disconnect()
            end
            statConnections[player] = nil
        end
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = baseStats.WalkSpeed
                humanoid.JumpHeight = baseStats.JumpHeight
                humanoid.JumpPower = baseStats.JumpHeight * 7
            end
        end
    end

    -- == NAME CHANGER FUNCTIONS ==
    local function changePlayerName(newName)
        local character = player.Character
        if not character then
            Library:Notify("Character not found!", 3)
            return
        end

        local oldName = character.Name

        pcall(function()
            character.Name = newName
            print("DEBUG: Changed character name in Workspace from " .. oldName .. " to " .. newName)
        end)

        local nametag = character:FindFirstChild("Nametag")
        if nametag then
            local playerName = nametag:FindFirstChild("PlayerName")
            if playerName then
                playerName.Text = newName
                print("DEBUG: Changed Nametag PlayerName to " .. newName)
                Library:Notify("Name changed to " .. newName, 3)
            else
                Library:Notify("PlayerName not found in Nametag!", 3)
                local children = nametag:GetChildren()
                local childNames = {}
                for _, child in pairs(children) do
                    table.insert(childNames, child.Name .. " (" .. child.ClassName .. ")")
                end
                print("DEBUG: Children of Nametag: " .. table.concat(childNames, ", "))
            end
        else
            Library:Notify("Nametag not found in character!", 3)
            local children = character:GetChildren()
            local childNames = {}
            for _, child in pairs(children) do
                table.insert(childNames, child.Name .. " (" .. child.ClassName .. ")")
            end
            print("DEBUG: Children of character: " .. table.concat(childNames, ", "))
        end
    end

    -- == UI ELEMENTS ==
    local HitboxToggle = MainGroupbox:AddToggle("HitboxToggle", {
        Text = "Enable Hitbox Extender",
        Default = false,
        Callback = function(Value)
            hitboxEnabled = Value
            if not hitboxEnabled then
                removeSpheres()
            else
                for _, descendant in pairs(Workspace:GetDescendants()) do
                    if descendant.Name:match("BALL") then
                        local ballPart = descendant:FindFirstChildWhichIsA("BasePart", true)
                        if ballPart then
                            createHitboxSphere(ballPart, descendant)
                        end
                    end
                end
            end
            Library:Notify(Value and "Hitbox Extender Enabled" or "Hitbox Extender Disabled", 3)
        end
    })

    local AimToggle = MainGroupbox:AddToggle("AimToggle", {
        Text = "Enable Aiming Beam",
        Default = false,
        Callback = function(Value)
            aimEnabled = Value
            if not aimEnabled then
                for character, _ in pairs(beams) do
                    removeBeam(character)
                end
            else
                for _, player in pairs(Players:GetPlayers()) do
                    if player.Character then
                        createAimIndicator(player.Character)
                    end
                end
            end
            Library:Notify(Value and "Aiming Beam Enabled" or "Aiming Beam Disabled", 3)
        end
    })

    local TransparencySlider = MainGroupbox:AddSlider("TransparencySlider", {
        Text = "Sphere Transparency",
        Default = 70,
        Min = 0,
        Max = 100,
        Rounding = 0,
        Suffix = "%",
        Callback = function(Value)
            sphereTransparency = Value / 100
            updateSpheres()
        end
    })

    local HitboxSizeSlider = MainGroupbox:AddSlider("HitboxSizeSlider", {
        Text = "Hitbox Size",
        Default = 10,
        Min = 5,
        Max = 50,
        Rounding = 0,
        Suffix = " studs",
        Callback = function(Value)
            EXTENDED_RANGE = Value
            updateSpheres()
        end
    })

    local ColorPickerToggle = MainGroupbox:AddToggle("ColorPickerToggle", {
        Text = "Sphere Color",
        Default = false
    })

    local SphereColorPicker = ColorPickerToggle:AddColorPicker("SphereColorPicker", {
        Default = Color3.fromRGB(255, 0, 0),
        Title = "Select Sphere Color",
        Callback = function(Value)
            sphereColor = Value
            updateSpheres()
        end
    })

    local MidAirToggle = MovementGroupbox:AddToggle("MidAirToggle", {
        Text = "Enable Mid-Air Control",
        Default = false,
        Callback = function(Value)
            midAirEnabled = Value
            if not midAirEnabled then
                for _, player in pairs(Players:GetPlayers()) do
                    disableMidAirControl(player)
                end
            else
                for _, player in pairs(Players:GetPlayers()) do
                    if player.Character then
                        setupMidAirControl(player)
                    end
                end
            end
            Library:Notify(Value and "Mid-Air Control Enabled" or "Mid-Air Control Disabled", 3)
        end
    })

    local MidAirSpeedSlider = MovementGroupbox:AddSlider("MidAirSpeedSlider", {
        Text = "Mid-Air Speed",
        Default = 20,
        Min = 10,
        Max = 50,
        Rounding = 0,
        Suffix = " studs/sec",
        Callback = function(Value)
            midAirSpeed = Value
        end
    })

    local ServeOverrideToggle = ServeGroupbox:AddToggle("ServeOverrideToggle", {
        Text = "Max Serve Power",
        Default = false,
        Callback = function(Value)
            serveOverrideEnabled = Value
            if serveOverrideEnabled then
                setupServeOverride()
            else
                disableServeOverride()
            end
            Library:Notify(Value and "Max Serve Power Enabled" or "Max Serve Power Disabled", 3)
        end
    })

    local StatModifierToggle = StatsGroupbox:AddToggle("StatModifierToggle", {
        Text = "Enable Stat Modifiers",
        Default = false,
        Callback = function(Value)
            statModifierEnabled = Value
            if not statModifierEnabled then
                for _, player in pairs(Players:GetPlayers()) do
                    disableStatModifiers(player)
                end
            else
                for _, player in pairs(Players:GetPlayers()) do
                    if player.Character then
                        setupStatModifiers(player)
                        applyStatModifiers()
                    end
                end
            end
            Library:Notify(Value and "Stat Modifiers Enabled" or "Stat Modifiers Disabled", 3)
        end
    })

    local SpeedMultiplierSlider = StatsGroupbox:AddSlider("SpeedMultiplierSlider", {
        Text = "Speed Multiplier",
        Default = 1.5,
        Min = 1,
        Max = 1.5,
        Rounding = 2,
        Suffix = "x",
        Callback = function(Value)
            multipliers.Speed = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local SpikePowerMultiplierSlider = StatsGroupbox:AddSlider("SpikePowerMultiplierSlider", {
        Text = "Spike Power Multiplier",
        Default = 1.5,
        Min = 1,
        Max = 1.5,
        Rounding = 2,
        Suffix = "x",
        Callback = function(Value)
            multipliers.SpikePower = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local JumpPowerMultiplierSlider = StatsGroupbox:AddSlider("JumpPowerMultiplierSlider", {
        Text = "Jump Height Multiplier",
        Default = 1.5,
        Min = 1,
        Max = 1.5,
        Rounding = 2,
        Suffix = "x",
        Callback = function(Value)
            multipliers.JumpPower = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local BumpPowerMultiplierSlider = StatsGroupbox:AddSlider("BumpPowerMultiplierSlider", {
        Text = "Bump Power Multiplier",
        Default = 1.5,
        Min = 1,
        Max = 1.5,
        Rounding = 2,
        Suffix = "x",
        Callback = function(Value)
            multipliers.BumpPower = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local DiveSpeedMultiplierSlider = StatsGroupbox:AddSlider("DiveSpeedMultiplierSlider", {
        Text = "Dive Speed Multiplier",
        Default = 1.5,
        Min = 1,
        Max = 1.5,
        Rounding = 2,
        Suffix = "x",
        Callback = function(Value)
            multipliers.DiveSpeed = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local ServePowerMultiplierSlider = StatsGroupbox:AddSlider("ServePowerMultiplierSlider", {
        Text = "Serve Power Multiplier",
        Default = 1.5,
        Min = 1,
        Max = 1.5,
        Rounding = 2,
        Suffix = "x",
        Callback = function(Value)
            multipliers.ServePower = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local SetPowerMultiplierSlider = StatsGroupbox:AddSlider("SetPowerMultiplierSlider", {
        Text = "Set Power Multiplier",
        Default = 1.5,
        Min = 1,
        Max = 1.5,
        Rounding = 2,
        Suffix = "x",
        Callback = function(Value)
            multipliers.SetPower = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local BlockPowerMultiplierSlider = StatsGroupbox:AddSlider("BlockPowerMultiplierSlider", {
        Text = "Block Power Multiplier",
        Default = 1.5,
        Min = 1,
        Max = 1.5,
        Rounding = 2,
        Suffix = "x",
        Callback = function(Value)
            multipliers.BlockPower = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local WalkSpeedSlider = StatMovementGroupbox:AddSlider("WalkSpeedSlider", {
        Text = "Walk Speed",
        Default = 16,
        Min = 0,
        Max = 100,
        Rounding = 0,
        Suffix = " studs/sec",
        Callback = function(Value)
            baseStats.WalkSpeed = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local JumpHeightSlider = StatMovementGroupbox:AddSlider("JumpHeightSlider", {
        Text = "Jump Height",
        Default = 7.2,
        Min = 0,
        Max = 20,
        Rounding = 1,
        Suffix = " studs",
        Callback = function(Value)
            baseStats.JumpHeight = Value
            if statModifierEnabled then
                applyStatModifiers()
            end
        end
    })

    local NameChangerTextbox = NameChangerGroupbox:AddInput("NameChangerTextbox", {
        Text = "Change Name",
        Default = player.Name,
        Placeholder = "Enter new name",
        Callback = function(Value)
            changePlayerName(Value)
        end
    })

    local ConfigNameInput = UiCustomizationGroupbox:AddInput("ConfigNameInput", {
        Text = "Config Name",
        Placeholder = "Enter config name",
        Callback = function(Value)
            -- Store the config name for saving/loading
        end
    })

    local SaveConfigButton = UiCustomizationGroupbox:AddButton({
        Text = "Save Config",
        Callback = function()
            local configName = ConfigNameInput.Value
            if configName == "" then
                Library:Notify("Please enter a config name!", 3)
                return
            end
            Library:SaveConfig(configName)
            Library:Notify("Config '" .. configName .. "' saved!", 3)
        end
    })

    local LoadConfigButton = UiCustomizationGroupbox:AddButton({
        Text = "Load Config",
        Callback = function()
            local configName = ConfigNameInput.Value
            if configName == "" then
                Library:Notify("Please enter a config name!", 3)
                return
            end
            Library:LoadConfig(configName)
            Library:Notify("Config '" .. configName .. "' loaded!", 3)
        end
    })

    local DeleteConfigButton = UiCustomizationGroupbox:AddButton({
        Text = "Delete Config",
        Callback = function()
            local configName = ConfigNameInput.Value
            if configName == "" then
                Library:Notify("Please enter a config name!", 3)
                return
            end
            Library:DeleteConfig(configName)
            Library:Notify("Config '" .. configName .. "' deleted!", 3)
        end
    })

    local ThemeDropdown = UiCustomizationGroupbox:AddDropdown("ThemeDropdown", {
        Text = "Select Theme",
        Values = {"Dark", "Light", "Mocha", "Aqua", "Jester"},
        Default = "Dark",
        Callback = function(Value)
            Library:SetTheme(Value)
            Library:Notify("Theme set to " .. Value, 3)
        end
    })

    local AccentColorPicker = UiCustomizationGroupbox:AddColorPicker("AccentColorPicker", {
        Text = "Accent Color",
        Default = Color3.fromRGB(0, 120, 215),
        Callback = function(Value)
            Library:SetAccentColor(Value)
            Library:Notify("Accent color updated!", 3)
        end
    })

    local BackgroundColorPicker = UiCustomizationGroupbox:AddColorPicker("BackgroundColorPicker", {
        Text = "Background Color",
        Default = Color3.fromRGB(30, 30, 30),
        Callback = function(Value)
            Library:SetBackgroundColor(Value)
            Library:Notify("Background color updated!", 3)
        end
    })

    local TextColorPicker = UiCustomizationGroupbox:AddColorPicker("TextColorPicker", {
        Text = "Text Color",
        Default = Color3.fromRGB(255, 255, 255),
        Callback = function(Value)
            Library:SetTextColor(Value)
            Library:Notify("Text color updated!", 3)
        end
    })

    -- == HITBOX EXTENDER: HANDLE PLAYER RESPAWN ==
    player.CharacterAdded:Connect(function(newCharacter)
        character = newCharacter
        humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        applyStatModifiers()
    end)

    -- == HITBOX EXTENDER: HANDLE CLICKING ==
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not hitboxEnabled then return end
        if gameProcessed or input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
        local currentTime = tick()
        if currentTime - lastHitTime < HIT_COOLDOWN then return end

        local ball, ballModel = findClosestBall()
        if not ball or not ballModel then
            print("No ball in range")
            return
        end

        local ballId = getBallId(ballModel)
        if not ballId then
            print("Could not get BallId from:", ballModel.Name)
            return
        end

        local args = {
            [1] = {
                ["Charge"] = 1,
                ["Action"] = "Spike",
                ["SpecialCharge"] = 0.000001,
                ["TiltDirection"] = humanoidRootPart.CFrame.LookVector,
                ["BallId"] = ballId,
                ["MoveDirection"] = humanoidRootPart.CFrame.LookVector,
                ["From"] = "Client",
                ["HitboxSize"] = Vector3.new(EXTENDED_RANGE * 2, EXTENDED_RANGE * 2, EXTENDED_RANGE * 2),
                ["LookVector"] = humanoidRootPart.CFrame.LookVector
            }
        }

        local success, result = pcall(function()
            return interactRemote:InvokeServer(unpack(args))
        end)
        print("Interact invoked. Success:", success, "Result:", result)

        lastHitTime = currentTime
    end)

    -- == AIMING BEAM: CONNECT NEW PLAYERS ==
    Players.PlayerAdded:Connect(function(player)
        print("New player joined:", player.Name)
        
        if player.Character and aimEnabled then
            print("Character already exists for new player:", player.Name)
            createAimIndicator(player.Character)
        end
        
        if player.Character and midAirEnabled then
            setupMidAirControl(player)
        end
        
        if player.Character and statModifierEnabled then
            setupStatModifiers(player)
            applyStatModifiers()
        end
        
        player.CharacterAdded:Connect(function(character)
            print("Character added for player:", player.Name)
            if aimEnabled then
                createAimIndicator(character)
            end
            if midAirEnabled then
                setupMidAirControl(player)
            end
            if statModifierEnabled then
                setupStatModifiers(player)
                applyStatModifiers()
            end
            character.AncestryChanged:Connect(function()
                if not character.Parent then
                    removeBeam(character)
                    disableMidAirControl(player)
                    disableStatModifiers(player)
                end
            end)
        end)
        
        local attempts = 0
        while not player.Character do
            attempts = attempts + 1
            if attempts > 50 then
                print("Failed to find character for player after polling:", player.Name)
                break
            end
            task.wait(0.1)
        end
        if player.Character and not beams[player.Character] and aimEnabled then
            print("Character found for new player (polling):", player.Name)
            createAimIndicator(player.Character)
        end
        if player.Character and not midAirConnections[player] and midAirEnabled then
            setupMidAirControl(player)
        end
        if player.Character and not statConnections[player] and statModifierEnabled then
            setupStatModifiers(player)
            applyStatModifiers()
        end
    end)

    -- == AIMING BEAM: CLEAN UP WHEN PLAYERS LEAVE ==
    Players.PlayerRemoving:Connect(function(player)
        print("Player left:", player.Name)
        if player.Character then
            removeBeam(player.Character)
            disableMidAirControl(player)
            disableStatModifiers(player)
        end
    end)

    -- == AIMING BEAM: HANDLE EXISTING PLAYERS ==
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and aimEnabled then
            print("Creating beam for existing player:", player.Name)
            createAimIndicator(player.Character)
        end
        if player.Character and midAirEnabled then
            setupMidAirControl(player)
        end
        if player.Character and statModifierEnabled then
            setupStatModifiers(player)
            applyStatModifiers()
        end
    end

    -- == SHOW THE UI ==
    Library:Toggle(true)
    print("UI should now be visible. Press RightControl to toggle.")
end

-- Initial notification
notify("Please enter the key to proceed.", 5)